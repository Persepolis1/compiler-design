Sentencial Form:
 prog 
USED RULE :
 prog                -> classDecl funcDef program funcBody ; 

Sentencial Form:
 classDecl funcDef program funcBody ; 
USED RULE :
 classDecl           -> class id classDeclInner { varAndFuncDecl } ; classDecl 

Sentencial Form:
 class id classDeclInner { varAndFuncDecl } ; classDecl funcDef program funcBody ; 
USED RULE :
 classDeclInner     -> EPSILON 

Sentencial Form:
 class id { varAndFuncDecl } ; classDecl funcDef program funcBody ; 
USED RULE :
 varAndFuncDecl      -> type id varAndFuncDeclTail 

Sentencial Form:
 class id { type id varAndFuncDeclTail } ; classDecl funcDef program funcBody ; 
USED RULE :
 type               -> int 

Sentencial Form:
 class id { int id varAndFuncDeclTail } ; classDecl funcDef program funcBody ; 
USED RULE :
 varAndFuncDeclTail  -> arraySize ; varAndFuncDecl 

Sentencial Form:
 class id { int id arraySize ; varAndFuncDecl } ; classDecl funcDef program funcBody ; 
USED RULE :
 arraySize          -> EPSILON 

Sentencial Form:
 class id { int id ; varAndFuncDecl } ; classDecl funcDef program funcBody ; 
USED RULE :
 varAndFuncDecl      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; classDecl funcDef program funcBody ; 
USED RULE :
 classDecl           -> class id classDeclInner { varAndFuncDecl } ; classDecl 

Sentencial Form:
 class id { int id ; } ; class id classDeclInner { varAndFuncDecl } ; classDecl funcDef program funcBody ; 
USED RULE :
 classDeclInner      -> : id classDeclInnerTail 

Sentencial Form:
 class id { int id ; } ; class id : id classDeclInnerTail { varAndFuncDecl } ; classDecl funcDef program funcBody ; 
USED RULE :
 classDeclInnerTail -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { varAndFuncDecl } ; classDecl funcDef program funcBody ; 
USED RULE :
 varAndFuncDecl      -> type id varAndFuncDeclTail 

Sentencial Form:
 class id { int id ; } ; class id : id { type id varAndFuncDeclTail } ; classDecl funcDef program funcBody ; 
USED RULE :
 type               -> int 

Sentencial Form:
 class id { int id ; } ; class id : id { int id varAndFuncDeclTail } ; classDecl funcDef program funcBody ; 
USED RULE :
 varAndFuncDeclTail  -> arraySize ; varAndFuncDecl 

Sentencial Form:
 class id { int id ; } ; class id : id { int id arraySize ; varAndFuncDecl } ; classDecl funcDef program funcBody ; 
USED RULE :
 arraySize          -> [ intNum ] arraySize 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] arraySize ; varAndFuncDecl } ; classDecl funcDef program funcBody ; 
USED RULE :
 arraySize          -> [ intNum ] arraySize 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] arraySize ; varAndFuncDecl } ; classDecl funcDef program funcBody ; 
USED RULE :
 arraySize          -> [ intNum ] arraySize 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] arraySize ; varAndFuncDecl } ; classDecl funcDef program funcBody ; 
USED RULE :
 arraySize          -> [ intNum ] arraySize 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] arraySize ; varAndFuncDecl } ; classDecl funcDef program funcBody ; 
USED RULE :
 arraySize          -> [ intNum ] arraySize 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] arraySize ; varAndFuncDecl } ; classDecl funcDef program funcBody ; 
USED RULE :
 arraySize          -> [ intNum ] arraySize 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] arraySize ; varAndFuncDecl } ; classDecl funcDef program funcBody ; 
USED RULE :
 arraySize          -> [ intNum ] arraySize 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] arraySize ; varAndFuncDecl } ; classDecl funcDef program funcBody ; 
USED RULE :
 arraySize          -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; varAndFuncDecl } ; classDecl funcDef program funcBody ; 
USED RULE :
 varAndFuncDecl      -> type id varAndFuncDeclTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; type id varAndFuncDeclTail } ; classDecl funcDef program funcBody ; 
USED RULE :
 type               -> float 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id varAndFuncDeclTail } ; classDecl funcDef program funcBody ; 
USED RULE :
 varAndFuncDeclTail  -> arraySize ; varAndFuncDecl 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id arraySize ; varAndFuncDecl } ; classDecl funcDef program funcBody ; 
USED RULE :
 arraySize          -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; varAndFuncDecl } ; classDecl funcDef program funcBody ; 
USED RULE :
 varAndFuncDecl      -> type id varAndFuncDeclTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; type id varAndFuncDeclTail } ; classDecl funcDef program funcBody ; 
USED RULE :
 type               -> int 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id varAndFuncDeclTail } ; classDecl funcDef program funcBody ; 
USED RULE :
 varAndFuncDeclTail  -> ( fParams ) ; varAndFuncDecl 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( fParams ) ; varAndFuncDecl } ; classDecl funcDef program funcBody ; 
USED RULE :
 fParams            -> type id arraySize fParamsTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( type id arraySize fParamsTail ) ; varAndFuncDecl } ; classDecl funcDef program funcBody ; 
USED RULE :
 type               -> int 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id arraySize fParamsTail ) ; varAndFuncDecl } ; classDecl funcDef program funcBody ; 
USED RULE :
 arraySize          -> [ intNum ] arraySize 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] arraySize fParamsTail ) ; varAndFuncDecl } ; classDecl funcDef program funcBody ; 
USED RULE :
 arraySize          -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] fParamsTail ) ; varAndFuncDecl } ; classDecl funcDef program funcBody ; 
USED RULE :
 fParamsTail        -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; varAndFuncDecl } ; classDecl funcDef program funcBody ; 
USED RULE :
 varAndFuncDecl      -> type id varAndFuncDeclTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; type id varAndFuncDeclTail } ; classDecl funcDef program funcBody ; 
USED RULE :
 type               -> int 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id varAndFuncDeclTail } ; classDecl funcDef program funcBody ; 
USED RULE :
 varAndFuncDeclTail  -> ( fParams ) ; varAndFuncDecl 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( fParams ) ; varAndFuncDecl } ; classDecl funcDef program funcBody ; 
USED RULE :
 fParams            -> type id arraySize fParamsTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( type id arraySize fParamsTail ) ; varAndFuncDecl } ; classDecl funcDef program funcBody ; 
USED RULE :
 type               -> int 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id arraySize fParamsTail ) ; varAndFuncDecl } ; classDecl funcDef program funcBody ; 
USED RULE :
 arraySize          -> [ intNum ] arraySize 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] arraySize fParamsTail ) ; varAndFuncDecl } ; classDecl funcDef program funcBody ; 
USED RULE :
 arraySize          -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] fParamsTail ) ; varAndFuncDecl } ; classDecl funcDef program funcBody ; 
USED RULE :
 fParamsTail        -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; varAndFuncDecl } ; classDecl funcDef program funcBody ; 
USED RULE :
 varAndFuncDecl      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; classDecl funcDef program funcBody ; 
USED RULE :
 classDecl           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; funcDef program funcBody ; 
USED RULE :
 funcDef            -> funcHead funcBody ; funcDef 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; funcHead funcBody ; funcDef program funcBody ; 
USED RULE :
 funcHead           -> type id funcHeadInner ( fParams ) 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; type id funcHeadInner ( fParams ) funcBody ; funcDef program funcBody ; 
USED RULE :
 type               -> int 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id funcHeadInner ( fParams ) funcBody ; funcDef program funcBody ; 
USED RULE :
 funcHeadInner      -> sr id 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( fParams ) funcBody ; funcDef program funcBody ; 
USED RULE :
 fParams            -> type id arraySize fParamsTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( type id arraySize fParamsTail ) funcBody ; funcDef program funcBody ; 
USED RULE :
 type               -> int 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id arraySize fParamsTail ) funcBody ; funcDef program funcBody ; 
USED RULE :
 arraySize          -> [ intNum ] arraySize 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] arraySize fParamsTail ) funcBody ; funcDef program funcBody ; 
USED RULE :
 arraySize          -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] fParamsTail ) funcBody ; funcDef program funcBody ; 
USED RULE :
 fParamsTail        -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) funcBody ; funcDef program funcBody ; 
USED RULE :
 funcBody           -> { funcBodyInner } 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { funcBodyInner } ; funcDef program funcBody ; 
USED RULE :
 funcBodyInner      -> varDecl statement 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { varDecl statement } ; funcDef program funcBody ; 
USED RULE :
 varDecl            -> type id varDeclTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { type id varDeclTail statement } ; funcDef program funcBody ; 
USED RULE :
 type               -> int 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id varDeclTail statement } ; funcDef program funcBody ; 
USED RULE :
 varDeclTail        -> arraySize ; varDeclTailTwo 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id arraySize ; varDeclTailTwo statement } ; funcDef program funcBody ; 
USED RULE :
 arraySize          -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; varDeclTailTwo statement } ; funcDef program funcBody ; 
USED RULE :
 varDeclTailTwo     -> varDecl 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; varDecl statement } ; funcDef program funcBody ; 
USED RULE :
 varDecl            -> type id varDeclTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; type id varDeclTail statement } ; funcDef program funcBody ; 
USED RULE :
 type               -> int 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id varDeclTail statement } ; funcDef program funcBody ; 
USED RULE :
 varDeclTail        -> arraySize ; varDeclTailTwo 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id arraySize ; varDeclTailTwo statement } ; funcDef program funcBody ; 
USED RULE :
 arraySize          -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; varDeclTailTwo statement } ; funcDef program funcBody ; 
USED RULE :
 varDeclTailTwo     -> id varDeclTailThree 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id varDeclTailThree statement } ; funcDef program funcBody ; 
USED RULE :
 varDeclTailThree   -> statementIdTwo 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id statementIdTwo statement } ; funcDef program funcBody ; 
USED RULE :
 statementIdTwo     -> assignStat ; statementIdThree 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id assignStat ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 assignStat         -> variable assignOp expr 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id variable assignOp expr ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 variable           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id assignOp expr ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 assignOp          -> = 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = expr ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 expr               -> arithExpr exprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = arithExpr exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = term arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = factor termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id idnest termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id indice idnestTail termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 indice             -> [ arithExpr ] indice 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ arithExpr ] indice idnestTail termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ term arithExprTail ] indice idnestTail termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ factor termTail arithExprTail ] indice idnestTail termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum termTail arithExprTail ] indice idnestTail termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum arithExprTail ] indice idnestTail termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] indice idnestTail termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] idnestTail termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 exprTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 statementIdThree   -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; statement } ; funcDef program funcBody ; 
USED RULE :
 statement          -> for ( statementForTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( statementForTail } ; funcDef program funcBody ; 
USED RULE :
 statementForTail   -> type id assignOp expr ; arithExpr relExpr ; id assignStat ) statBlock ; statementTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( type id assignOp expr ; arithExpr relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 type               -> int 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id assignOp expr ; arithExpr relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 assignOp          -> = 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = expr ; arithExpr relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 expr               -> arithExpr exprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = arithExpr exprTail ; arithExpr relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = term arithExprTail exprTail ; arithExpr relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = factor termTail arithExprTail exprTail ; arithExpr relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum termTail arithExprTail exprTail ; arithExpr relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum arithExprTail exprTail ; arithExpr relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum exprTail ; arithExpr relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 exprTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; arithExpr relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; term arithExprTail relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; factor termTail arithExprTail relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id idnest termTail arithExprTail relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id indice idnestTail termTail arithExprTail relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id idnestTail termTail arithExprTail relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id termTail arithExprTail relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id arithExprTail relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 relExpr            -> relOp arithExpr 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id relOp arithExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 relOp             -> gt 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt arithExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt term arithExprTail ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt factor termTail arithExprTail ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum termTail arithExprTail ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum arithExprTail ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 assignStat         -> variable assignOp expr 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id variable assignOp expr ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 variable           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id assignOp expr ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 assignOp          -> = 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = expr ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 expr               -> arithExpr exprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = arithExpr exprTail ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = term arithExprTail exprTail ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = factor termTail arithExprTail exprTail ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id idnest termTail arithExprTail exprTail ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id indice idnestTail termTail arithExprTail exprTail ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id idnestTail termTail arithExprTail exprTail ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id termTail arithExprTail exprTail ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id arithExprTail exprTail ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> addOp term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id addOp term arithExprTail exprTail ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 addOp             -> - 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - term arithExprTail exprTail ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - factor termTail arithExprTail exprTail ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum termTail arithExprTail exprTail ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum arithExprTail exprTail ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum exprTail ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 exprTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 statBlock          -> { statBlockTail } 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { statBlockTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 statBlockTail      -> statement 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { statement } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 statement          -> if ( expr ) then statBlock else statBlock ; statementTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( expr ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 expr               -> arithExpr exprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( arithExpr exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( term arithExprTail exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( factor termTail arithExprTail exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id idnest termTail arithExprTail exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id indice idnestTail termTail arithExprTail exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 indice             -> [ arithExpr ] indice 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ arithExpr ] indice idnestTail termTail arithExprTail exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ term arithExprTail ] indice idnestTail termTail arithExprTail exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ factor termTail arithExprTail ] indice idnestTail termTail arithExprTail exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id idnest termTail arithExprTail ] indice idnestTail termTail arithExprTail exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id indice idnestTail termTail arithExprTail ] indice idnestTail termTail arithExprTail exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id idnestTail termTail arithExprTail ] indice idnestTail termTail arithExprTail exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id termTail arithExprTail ] indice idnestTail termTail arithExprTail exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id arithExprTail ] indice idnestTail termTail arithExprTail exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] indice idnestTail termTail arithExprTail exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] idnestTail termTail arithExprTail exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] termTail arithExprTail exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] arithExprTail exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 exprTail           -> relExpr 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] relExpr ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 relExpr            -> relOp arithExpr 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] relOp arithExpr ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 relOp             -> gt 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt arithExpr ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt term arithExprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt factor termTail arithExprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id idnest termTail arithExprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id indice idnestTail termTail arithExprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id idnestTail termTail arithExprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id termTail arithExprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id arithExprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 statBlock          -> { statBlockTail } 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { statBlockTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 statBlockTail      -> id statementId 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id statementId } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 statementId        -> assignStat ; statementTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id assignStat ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 assignStat         -> variable assignOp expr 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id variable assignOp expr ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 variable           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id assignOp expr ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 assignOp          -> = 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = expr ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 expr               -> arithExpr exprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = arithExpr exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = term arithExprTail exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = factor termTail arithExprTail exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id idnest termTail arithExprTail exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id indice idnestTail termTail arithExprTail exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 indice             -> [ arithExpr ] indice 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ arithExpr ] indice idnestTail termTail arithExprTail exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ term arithExprTail ] indice idnestTail termTail arithExprTail exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ factor termTail arithExprTail ] indice idnestTail termTail arithExprTail exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id idnest termTail arithExprTail ] indice idnestTail termTail arithExprTail exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id indice idnestTail termTail arithExprTail ] indice idnestTail termTail arithExprTail exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id idnestTail termTail arithExprTail ] indice idnestTail termTail arithExprTail exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id termTail arithExprTail ] indice idnestTail termTail arithExprTail exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id arithExprTail ] indice idnestTail termTail arithExprTail exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] indice idnestTail termTail arithExprTail exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] idnestTail termTail arithExprTail exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] termTail arithExprTail exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] arithExprTail exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 exprTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 statementTail      -> statement 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; statement } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 statement          -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 statBlock          -> { statBlockTail } 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { statBlockTail } ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 statBlockTail      -> statement 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { statement } ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 statement          -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 statementTail      -> statement 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; statement } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 statement          -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 statementTail      -> statement 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; statement } ; funcDef program funcBody ; 
USED RULE :
 statement          -> return ( expr ) ; statementTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( expr ) ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 expr               -> arithExpr exprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( arithExpr exprTail ) ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( term arithExprTail exprTail ) ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( factor termTail arithExprTail exprTail ) ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id idnest termTail arithExprTail exprTail ) ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id indice idnestTail termTail arithExprTail exprTail ) ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id idnestTail termTail arithExprTail exprTail ) ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id termTail arithExprTail exprTail ) ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id arithExprTail exprTail ) ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id exprTail ) ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 exprTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 statementTail      -> statement 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; statement } ; funcDef program funcBody ; 
USED RULE :
 statement          -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; funcDef program funcBody ; 
USED RULE :
 funcDef            -> funcHead funcBody ; funcDef 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; funcHead funcBody ; funcDef program funcBody ; 
USED RULE :
 funcHead           -> type id funcHeadInner ( fParams ) 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; type id funcHeadInner ( fParams ) funcBody ; funcDef program funcBody ; 
USED RULE :
 type               -> int 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id funcHeadInner ( fParams ) funcBody ; funcDef program funcBody ; 
USED RULE :
 funcHeadInner      -> sr id 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( fParams ) funcBody ; funcDef program funcBody ; 
USED RULE :
 fParams            -> type id arraySize fParamsTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( type id arraySize fParamsTail ) funcBody ; funcDef program funcBody ; 
USED RULE :
 type               -> int 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id arraySize fParamsTail ) funcBody ; funcDef program funcBody ; 
USED RULE :
 arraySize          -> [ intNum ] arraySize 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] arraySize fParamsTail ) funcBody ; funcDef program funcBody ; 
USED RULE :
 arraySize          -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] fParamsTail ) funcBody ; funcDef program funcBody ; 
USED RULE :
 fParamsTail        -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) funcBody ; funcDef program funcBody ; 
USED RULE :
 funcBody           -> { funcBodyInner } 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { funcBodyInner } ; funcDef program funcBody ; 
USED RULE :
 funcBodyInner      -> varDecl statement 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { varDecl statement } ; funcDef program funcBody ; 
USED RULE :
 varDecl            -> type id varDeclTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { type id varDeclTail statement } ; funcDef program funcBody ; 
USED RULE :
 type               -> int 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id varDeclTail statement } ; funcDef program funcBody ; 
USED RULE :
 varDeclTail        -> arraySize ; varDeclTailTwo 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id arraySize ; varDeclTailTwo statement } ; funcDef program funcBody ; 
USED RULE :
 arraySize          -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; varDeclTailTwo statement } ; funcDef program funcBody ; 
USED RULE :
 varDeclTailTwo     -> varDecl 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; varDecl statement } ; funcDef program funcBody ; 
USED RULE :
 varDecl            -> type id varDeclTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; type id varDeclTail statement } ; funcDef program funcBody ; 
USED RULE :
 type               -> int 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id varDeclTail statement } ; funcDef program funcBody ; 
USED RULE :
 varDeclTail        -> arraySize ; varDeclTailTwo 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id arraySize ; varDeclTailTwo statement } ; funcDef program funcBody ; 
USED RULE :
 arraySize          -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; varDeclTailTwo statement } ; funcDef program funcBody ; 
USED RULE :
 varDeclTailTwo     -> id varDeclTailThree 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id varDeclTailThree statement } ; funcDef program funcBody ; 
USED RULE :
 varDeclTailThree   -> statementIdTwo 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id statementIdTwo statement } ; funcDef program funcBody ; 
USED RULE :
 statementIdTwo     -> assignStat ; statementIdThree 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id assignStat ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 assignStat         -> variable assignOp expr 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id variable assignOp expr ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 variable           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id assignOp expr ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 assignOp          -> = 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = expr ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 expr               -> arithExpr exprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = arithExpr exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = term arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = factor termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id idnest termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id indice idnestTail termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 indice             -> [ arithExpr ] indice 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ arithExpr ] indice idnestTail termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ term arithExprTail ] indice idnestTail termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ factor termTail arithExprTail ] indice idnestTail termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum termTail arithExprTail ] indice idnestTail termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum arithExprTail ] indice idnestTail termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] indice idnestTail termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] idnestTail termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 exprTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 statementIdThree   -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; statement } ; funcDef program funcBody ; 
USED RULE :
 statement          -> for ( statementForTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( statementForTail } ; funcDef program funcBody ; 
USED RULE :
 statementForTail   -> type id assignOp expr ; arithExpr relExpr ; id assignStat ) statBlock ; statementTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( type id assignOp expr ; arithExpr relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 type               -> int 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id assignOp expr ; arithExpr relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 assignOp          -> = 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = expr ; arithExpr relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 expr               -> arithExpr exprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = arithExpr exprTail ; arithExpr relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = term arithExprTail exprTail ; arithExpr relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = factor termTail arithExprTail exprTail ; arithExpr relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum termTail arithExprTail exprTail ; arithExpr relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum arithExprTail exprTail ; arithExpr relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum exprTail ; arithExpr relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 exprTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; arithExpr relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; term arithExprTail relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; factor termTail arithExprTail relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id idnest termTail arithExprTail relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id indice idnestTail termTail arithExprTail relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id idnestTail termTail arithExprTail relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id termTail arithExprTail relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id arithExprTail relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id relExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 relExpr            -> relOp arithExpr 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id relOp arithExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 relOp             -> leq 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq arithExpr ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq term arithExprTail ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq factor termTail arithExprTail ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum termTail arithExprTail ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum arithExprTail ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id assignStat ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 assignStat         -> variable assignOp expr 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id variable assignOp expr ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 variable           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id assignOp expr ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 assignOp          -> = 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = expr ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 expr               -> arithExpr exprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = arithExpr exprTail ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = term arithExprTail exprTail ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = factor termTail arithExprTail exprTail ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 factor             -> ( arithExpr ) 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( arithExpr ) termTail arithExprTail exprTail ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( term arithExprTail ) termTail arithExprTail exprTail ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( factor termTail arithExprTail ) termTail arithExprTail exprTail ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id idnest termTail arithExprTail ) termTail arithExprTail exprTail ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id indice idnestTail termTail arithExprTail ) termTail arithExprTail exprTail ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id idnestTail termTail arithExprTail ) termTail arithExprTail exprTail ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id termTail arithExprTail ) termTail arithExprTail exprTail ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id arithExprTail ) termTail arithExprTail exprTail ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) termTail arithExprTail exprTail ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) arithExprTail exprTail ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> addOp term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) addOp term arithExprTail exprTail ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 addOp             -> + 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + term arithExprTail exprTail ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + factor termTail arithExprTail exprTail ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum termTail arithExprTail exprTail ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum arithExprTail exprTail ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum exprTail ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 exprTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) statBlock ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 statBlock          -> { statBlockTail } 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { statBlockTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 statBlockTail      -> statement 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { statement } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 statement          -> if ( expr ) then statBlock else statBlock ; statementTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( expr ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 expr               -> arithExpr exprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( arithExpr exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( term arithExprTail exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( factor termTail arithExprTail exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id idnest termTail arithExprTail exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id indice idnestTail termTail arithExprTail exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 indice             -> [ arithExpr ] indice 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ arithExpr ] indice idnestTail termTail arithExprTail exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ term arithExprTail ] indice idnestTail termTail arithExprTail exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ factor termTail arithExprTail ] indice idnestTail termTail arithExprTail exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id idnest termTail arithExprTail ] indice idnestTail termTail arithExprTail exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id indice idnestTail termTail arithExprTail ] indice idnestTail termTail arithExprTail exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id idnestTail termTail arithExprTail ] indice idnestTail termTail arithExprTail exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id termTail arithExprTail ] indice idnestTail termTail arithExprTail exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id arithExprTail ] indice idnestTail termTail arithExprTail exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] indice idnestTail termTail arithExprTail exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] idnestTail termTail arithExprTail exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] termTail arithExprTail exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] arithExprTail exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] exprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 exprTail           -> relExpr 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] relExpr ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 relExpr            -> relOp arithExpr 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] relOp arithExpr ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 relOp             -> lt 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt arithExpr ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt term arithExprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt factor termTail arithExprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id idnest termTail arithExprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id indice idnestTail termTail arithExprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id idnestTail termTail arithExprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id termTail arithExprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id arithExprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> addOp term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id addOp term arithExprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 addOp             -> + 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + term arithExprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + factor termTail arithExprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum termTail arithExprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> multOp factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum multOp factor termTail arithExprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 multOp            -> / 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / factor termTail arithExprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum termTail arithExprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum arithExprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> addOp term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum addOp term arithExprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 addOp             -> or 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or term arithExprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or factor termTail arithExprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id idnest termTail arithExprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id indice idnestTail termTail arithExprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id idnestTail termTail arithExprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id termTail arithExprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id arithExprTail ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then statBlock else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 statBlock          -> { statBlockTail } 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { statBlockTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 statBlockTail      -> id statementId 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id statementId } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 statementId        -> assignStat ; statementTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id assignStat ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 assignStat         -> variable assignOp expr 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id variable assignOp expr ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 variable           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id assignOp expr ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 assignOp          -> = 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = expr ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 expr               -> arithExpr exprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = arithExpr exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = term arithExprTail exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = factor termTail arithExprTail exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id idnest termTail arithExprTail exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id indice idnestTail termTail arithExprTail exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 indice             -> [ arithExpr ] indice 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ arithExpr ] indice idnestTail termTail arithExprTail exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ term arithExprTail ] indice idnestTail termTail arithExprTail exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ factor termTail arithExprTail ] indice idnestTail termTail arithExprTail exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id idnest termTail arithExprTail ] indice idnestTail termTail arithExprTail exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id indice idnestTail termTail arithExprTail ] indice idnestTail termTail arithExprTail exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id idnestTail termTail arithExprTail ] indice idnestTail termTail arithExprTail exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id termTail arithExprTail ] indice idnestTail termTail arithExprTail exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id arithExprTail ] indice idnestTail termTail arithExprTail exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] indice idnestTail termTail arithExprTail exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] idnestTail termTail arithExprTail exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] termTail arithExprTail exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] arithExprTail exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] exprTail ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 exprTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; statementTail } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 statementTail      -> statement 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; statement } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 statement          -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else statBlock ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 statBlock          -> { statBlockTail } 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { statBlockTail } ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 statBlockTail      -> statement 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { statement } ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 statement          -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; statementTail } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 statementTail      -> statement 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; statement } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 statement          -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 statementTail      -> statement 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; statement } ; funcDef program funcBody ; 
USED RULE :
 statement          -> return ( expr ) ; statementTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( expr ) ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 expr               -> arithExpr exprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( arithExpr exprTail ) ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( term arithExprTail exprTail ) ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( factor termTail arithExprTail exprTail ) ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id idnest termTail arithExprTail exprTail ) ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id indice idnestTail termTail arithExprTail exprTail ) ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id idnestTail termTail arithExprTail exprTail ) ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id termTail arithExprTail exprTail ) ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id arithExprTail exprTail ) ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id exprTail ) ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 exprTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 statementTail      -> statement 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; statement } ; funcDef program funcBody ; 
USED RULE :
 statement          -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; funcDef program funcBody ; 
USED RULE :
 funcDef            -> funcHead funcBody ; funcDef 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; funcHead funcBody ; funcDef program funcBody ; 
USED RULE :
 funcHead           -> type id funcHeadInner ( fParams ) 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; type id funcHeadInner ( fParams ) funcBody ; funcDef program funcBody ; 
USED RULE :
 type               -> float 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id funcHeadInner ( fParams ) funcBody ; funcDef program funcBody ; 
USED RULE :
 funcHeadInner      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( fParams ) funcBody ; funcDef program funcBody ; 
USED RULE :
 fParams            -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) funcBody ; funcDef program funcBody ; 
USED RULE :
 funcBody           -> { funcBodyInner } 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { funcBodyInner } ; funcDef program funcBody ; 
USED RULE :
 funcBodyInner      -> varDecl statement 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { varDecl statement } ; funcDef program funcBody ; 
USED RULE :
 varDecl            -> type id varDeclTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { type id varDeclTail statement } ; funcDef program funcBody ; 
USED RULE :
 type               -> float 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id varDeclTail statement } ; funcDef program funcBody ; 
USED RULE :
 varDeclTail        -> arraySize ; varDeclTailTwo 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id arraySize ; varDeclTailTwo statement } ; funcDef program funcBody ; 
USED RULE :
 arraySize          -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; varDeclTailTwo statement } ; funcDef program funcBody ; 
USED RULE :
 varDeclTailTwo     -> id varDeclTailThree 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id varDeclTailThree statement } ; funcDef program funcBody ; 
USED RULE :
 varDeclTailThree   -> statementIdTwo 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id statementIdTwo statement } ; funcDef program funcBody ; 
USED RULE :
 statementIdTwo     -> assignStat ; statementIdThree 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id assignStat ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 assignStat         -> variable assignOp expr 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id variable assignOp expr ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 variable           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id assignOp expr ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 assignOp          -> = 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = expr ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 expr               -> arithExpr exprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = arithExpr exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = term arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = factor termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> multOp factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum multOp factor termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 multOp            -> * 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * factor termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 factor             -> ( arithExpr ) 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( arithExpr ) termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( term arithExprTail ) termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( factor termTail arithExprTail ) termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum termTail arithExprTail ) termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum arithExprTail ) termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> addOp term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum addOp term arithExprTail ) termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 addOp             -> + 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + term arithExprTail ) termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + factor termTail arithExprTail ) termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 factor             -> floatNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum termTail arithExprTail ) termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> multOp factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum multOp factor termTail arithExprTail ) termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 multOp            -> / 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / factor termTail arithExprTail ) termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 factor             -> floatNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum termTail arithExprTail ) termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum arithExprTail ) termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 exprTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 statementIdThree   -> id statementIdTwo 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id statementIdTwo statement } ; funcDef program funcBody ; 
USED RULE :
 statementIdTwo     -> assignStat ; statementIdThree 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id assignStat ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 assignStat         -> variable assignOp expr 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id variable assignOp expr ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 variable           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id assignOp expr ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 assignOp          -> = 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = expr ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 expr               -> arithExpr exprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = arithExpr exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = term arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = factor termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 factor             -> floatNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> addOp term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum addOp term arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 addOp             -> + 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + term arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + factor termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 factor             -> ( arithExpr ) 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( arithExpr ) termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( term arithExprTail ) termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( factor termTail arithExprTail ) termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 factor             -> ( arithExpr ) 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( arithExpr ) termTail arithExprTail ) termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( term arithExprTail ) termTail arithExprTail ) termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( factor termTail arithExprTail ) termTail arithExprTail ) termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 factor             -> floatNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum termTail arithExprTail ) termTail arithExprTail ) termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> multOp factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum multOp factor termTail arithExprTail ) termTail arithExprTail ) termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 multOp            -> * 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * factor termTail arithExprTail ) termTail arithExprTail ) termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 factor             -> floatNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum termTail arithExprTail ) termTail arithExprTail ) termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum arithExprTail ) termTail arithExprTail ) termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) termTail arithExprTail ) termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) arithExprTail ) termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> addOp term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) addOp term arithExprTail ) termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 addOp             -> - 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - term arithExprTail ) termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - factor termTail arithExprTail ) termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 factor             -> floatNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum termTail arithExprTail ) termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum arithExprTail ) termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> addOp term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) addOp term arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 addOp             -> + 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + term arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + factor termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 factor             -> floatNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum termTail arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum arithExprTail exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum exprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 exprTail           -> relExpr 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum relExpr ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 relExpr            -> relOp arithExpr 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum relOp arithExpr ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 relOp             -> gt 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt arithExpr ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt term arithExprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt factor termTail arithExprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum termTail arithExprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> multOp factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum multOp factor termTail arithExprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 multOp            -> and 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and factor termTail arithExprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 factor             -> not factor 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not factor termTail arithExprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 factor             -> sign factor 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not sign factor termTail arithExprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 sign               -> - 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - factor termTail arithExprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum termTail arithExprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum arithExprTail ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; statementIdThree statement } ; funcDef program funcBody ; 
USED RULE :
 statementIdThree   -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; statement } ; funcDef program funcBody ; 
USED RULE :
 statement          -> return ( expr ) ; statementTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( expr ) ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 expr               -> arithExpr exprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( arithExpr exprTail ) ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( term arithExprTail exprTail ) ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( factor termTail arithExprTail exprTail ) ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id idnest termTail arithExprTail exprTail ) ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id indice idnestTail termTail arithExprTail exprTail ) ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id idnestTail termTail arithExprTail exprTail ) ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id termTail arithExprTail exprTail ) ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id arithExprTail exprTail ) ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id exprTail ) ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 exprTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; statementTail } ; funcDef program funcBody ; 
USED RULE :
 statementTail      -> statement 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; statement } ; funcDef program funcBody ; 
USED RULE :
 statement          -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; funcDef program funcBody ; 
USED RULE :
 funcDef            -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program funcBody ; 
USED RULE :
 funcBody           -> { funcBodyInner } 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { funcBodyInner } ; 
USED RULE :
 funcBodyInner      -> varDecl statement 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { varDecl statement } ; 
USED RULE :
 varDecl            -> type id varDeclTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { type id varDeclTail statement } ; 
USED RULE :
 type               -> int 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id varDeclTail statement } ; 
USED RULE :
 varDeclTail        -> arraySize ; varDeclTailTwo 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id arraySize ; varDeclTailTwo statement } ; 
USED RULE :
 arraySize          -> [ intNum ] arraySize 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] arraySize ; varDeclTailTwo statement } ; 
USED RULE :
 arraySize          -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; varDeclTailTwo statement } ; 
USED RULE :
 varDeclTailTwo     -> varDecl 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; varDecl statement } ; 
USED RULE :
 varDecl            -> type id varDeclTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; type id varDeclTail statement } ; 
USED RULE :
 type               -> int 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id varDeclTail statement } ; 
USED RULE :
 varDeclTail        -> arraySize ; varDeclTailTwo 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id arraySize ; varDeclTailTwo statement } ; 
USED RULE :
 arraySize          -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; varDeclTailTwo statement } ; 
USED RULE :
 varDeclTailTwo     -> varDecl 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; varDecl statement } ; 
USED RULE :
 varDecl            -> type id varDeclTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; type id varDeclTail statement } ; 
USED RULE :
 type               -> int 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id varDeclTail statement } ; 
USED RULE :
 varDeclTail        -> arraySize ; varDeclTailTwo 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id arraySize ; varDeclTailTwo statement } ; 
USED RULE :
 arraySize          -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; varDeclTailTwo statement } ; 
USED RULE :
 varDeclTailTwo     -> varDecl 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; varDecl statement } ; 
USED RULE :
 varDecl            -> type id varDeclTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; type id varDeclTail statement } ; 
USED RULE :
 type               -> int 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id varDeclTail statement } ; 
USED RULE :
 varDeclTail        -> arraySize ; varDeclTailTwo 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id arraySize ; varDeclTailTwo statement } ; 
USED RULE :
 arraySize          -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; varDeclTailTwo statement } ; 
USED RULE :
 varDeclTailTwo     -> id varDeclTailThree 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id varDeclTailThree statement } ; 
USED RULE :
 varDeclTailThree   -> varDeclId 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id varDeclId statement } ; 
USED RULE :
 varDeclId          -> id varDeclTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id varDeclTail statement } ; 
USED RULE :
 varDeclTail        -> arraySize ; varDeclTailTwo 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id arraySize ; varDeclTailTwo statement } ; 
USED RULE :
 arraySize          -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; varDeclTailTwo statement } ; 
USED RULE :
 varDeclTailTwo     -> id varDeclTailThree 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id varDeclTailThree statement } ; 
USED RULE :
 varDeclTailThree   -> varDeclId 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id varDeclId statement } ; 
USED RULE :
 varDeclId          -> id varDeclTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id varDeclTail statement } ; 
USED RULE :
 varDeclTail        -> arraySize ; varDeclTailTwo 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id arraySize ; varDeclTailTwo statement } ; 
USED RULE :
 arraySize          -> [ intNum ] arraySize 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] arraySize ; varDeclTailTwo statement } ; 
USED RULE :
 arraySize          -> [ intNum ] arraySize 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] arraySize ; varDeclTailTwo statement } ; 
USED RULE :
 arraySize          -> [ intNum ] arraySize 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] arraySize ; varDeclTailTwo statement } ; 
USED RULE :
 arraySize          -> [ intNum ] arraySize 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] arraySize ; varDeclTailTwo statement } ; 
USED RULE :
 arraySize          -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; varDeclTailTwo statement } ; 
USED RULE :
 varDeclTailTwo     -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; statement } ; 
USED RULE :
 statement          -> for ( statementForTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( statementForTail } ; 
USED RULE :
 statementForTail   -> type id assignOp expr ; arithExpr relExpr ; id assignStat ) statBlock ; statementTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( type id assignOp expr ; arithExpr relExpr ; id assignStat ) statBlock ; statementTail } ; 
USED RULE :
 type               -> int 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id assignOp expr ; arithExpr relExpr ; id assignStat ) statBlock ; statementTail } ; 
USED RULE :
 assignOp          -> = 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = expr ; arithExpr relExpr ; id assignStat ) statBlock ; statementTail } ; 
USED RULE :
 expr               -> arithExpr exprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = arithExpr exprTail ; arithExpr relExpr ; id assignStat ) statBlock ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = term arithExprTail exprTail ; arithExpr relExpr ; id assignStat ) statBlock ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = factor termTail arithExprTail exprTail ; arithExpr relExpr ; id assignStat ) statBlock ; statementTail } ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum termTail arithExprTail exprTail ; arithExpr relExpr ; id assignStat ) statBlock ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum arithExprTail exprTail ; arithExpr relExpr ; id assignStat ) statBlock ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum exprTail ; arithExpr relExpr ; id assignStat ) statBlock ; statementTail } ; 
USED RULE :
 exprTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; arithExpr relExpr ; id assignStat ) statBlock ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; term arithExprTail relExpr ; id assignStat ) statBlock ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; factor termTail arithExprTail relExpr ; id assignStat ) statBlock ; statementTail } ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id idnest termTail arithExprTail relExpr ; id assignStat ) statBlock ; statementTail } ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id indice idnestTail termTail arithExprTail relExpr ; id assignStat ) statBlock ; statementTail } ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id idnestTail termTail arithExprTail relExpr ; id assignStat ) statBlock ; statementTail } ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id termTail arithExprTail relExpr ; id assignStat ) statBlock ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id arithExprTail relExpr ; id assignStat ) statBlock ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id relExpr ; id assignStat ) statBlock ; statementTail } ; 
USED RULE :
 relExpr            -> relOp arithExpr 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id relOp arithExpr ; id assignStat ) statBlock ; statementTail } ; 
USED RULE :
 relOp             -> leq 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq arithExpr ; id assignStat ) statBlock ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq term arithExprTail ; id assignStat ) statBlock ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq factor termTail arithExprTail ; id assignStat ) statBlock ; statementTail } ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum termTail arithExprTail ; id assignStat ) statBlock ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum arithExprTail ; id assignStat ) statBlock ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id assignStat ) statBlock ; statementTail } ; 
USED RULE :
 assignStat         -> variable assignOp expr 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id variable assignOp expr ) statBlock ; statementTail } ; 
USED RULE :
 variable           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id assignOp expr ) statBlock ; statementTail } ; 
USED RULE :
 assignOp          -> = 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = expr ) statBlock ; statementTail } ; 
USED RULE :
 expr               -> arithExpr exprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = arithExpr exprTail ) statBlock ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = term arithExprTail exprTail ) statBlock ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = factor termTail arithExprTail exprTail ) statBlock ; statementTail } ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id idnest termTail arithExprTail exprTail ) statBlock ; statementTail } ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id indice idnestTail termTail arithExprTail exprTail ) statBlock ; statementTail } ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id idnestTail termTail arithExprTail exprTail ) statBlock ; statementTail } ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id termTail arithExprTail exprTail ) statBlock ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id arithExprTail exprTail ) statBlock ; statementTail } ; 
USED RULE :
 arithExprTail      -> addOp term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id addOp term arithExprTail exprTail ) statBlock ; statementTail } ; 
USED RULE :
 addOp             -> + 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + term arithExprTail exprTail ) statBlock ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + factor termTail arithExprTail exprTail ) statBlock ; statementTail } ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum termTail arithExprTail exprTail ) statBlock ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum arithExprTail exprTail ) statBlock ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum exprTail ) statBlock ; statementTail } ; 
USED RULE :
 exprTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) statBlock ; statementTail } ; 
USED RULE :
 statBlock          -> { statBlockTail } 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { statBlockTail } ; statementTail } ; 
USED RULE :
 statBlockTail      -> statement 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { statement } ; statementTail } ; 
USED RULE :
 statement          -> get ( id idnest ) ; statementTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id idnest ) ; statementTail } ; statementTail } ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id indice idnestTail ) ; statementTail } ; statementTail } ; 
USED RULE :
 indice             -> [ arithExpr ] indice 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ arithExpr ] indice idnestTail ) ; statementTail } ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ term arithExprTail ] indice idnestTail ) ; statementTail } ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ factor termTail arithExprTail ] indice idnestTail ) ; statementTail } ; statementTail } ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id idnest termTail arithExprTail ] indice idnestTail ) ; statementTail } ; statementTail } ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id indice idnestTail termTail arithExprTail ] indice idnestTail ) ; statementTail } ; statementTail } ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id idnestTail termTail arithExprTail ] indice idnestTail ) ; statementTail } ; statementTail } ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id termTail arithExprTail ] indice idnestTail ) ; statementTail } ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id arithExprTail ] indice idnestTail ) ; statementTail } ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] indice idnestTail ) ; statementTail } ; statementTail } ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] idnestTail ) ; statementTail } ; statementTail } ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; statementTail } ; statementTail } ; 
USED RULE :
 statementTail      -> id statementId 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id statementId } ; statementTail } ; 
USED RULE :
 statementId        -> assignStat ; statementTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id assignStat ; statementTail } ; statementTail } ; 
USED RULE :
 assignStat         -> variable assignOp expr 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id variable assignOp expr ; statementTail } ; statementTail } ; 
USED RULE :
 variable           -> [ arithExpr ] indice variableTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ arithExpr ] indice variableTail assignOp expr ; statementTail } ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ term arithExprTail ] indice variableTail assignOp expr ; statementTail } ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ factor termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; statementTail } ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id idnest termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; statementTail } ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; statementTail } ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; statementTail } ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id arithExprTail ] indice variableTail assignOp expr ; statementTail } ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] indice variableTail assignOp expr ; statementTail } ; statementTail } ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] variableTail assignOp expr ; statementTail } ; statementTail } ; 
USED RULE :
 variableTail       -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] assignOp expr ; statementTail } ; statementTail } ; 
USED RULE :
 assignOp          -> = 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = expr ; statementTail } ; statementTail } ; 
USED RULE :
 expr               -> arithExpr exprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = arithExpr exprTail ; statementTail } ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = term arithExprTail exprTail ; statementTail } ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = factor termTail arithExprTail exprTail ; statementTail } ; statementTail } ; 
USED RULE :
 factor             -> ( arithExpr ) 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( arithExpr ) termTail arithExprTail exprTail ; statementTail } ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( term arithExprTail ) termTail arithExprTail exprTail ; statementTail } ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( factor termTail arithExprTail ) termTail arithExprTail exprTail ; statementTail } ; statementTail } ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id idnest termTail arithExprTail ) termTail arithExprTail exprTail ; statementTail } ; statementTail } ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id indice idnestTail termTail arithExprTail ) termTail arithExprTail exprTail ; statementTail } ; statementTail } ; 
USED RULE :
 indice             -> [ arithExpr ] indice 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ arithExpr ] indice idnestTail termTail arithExprTail ) termTail arithExprTail exprTail ; statementTail } ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ term arithExprTail ] indice idnestTail termTail arithExprTail ) termTail arithExprTail exprTail ; statementTail } ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ factor termTail arithExprTail ] indice idnestTail termTail arithExprTail ) termTail arithExprTail exprTail ; statementTail } ; statementTail } ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id idnest termTail arithExprTail ] indice idnestTail termTail arithExprTail ) termTail arithExprTail exprTail ; statementTail } ; statementTail } ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id indice idnestTail termTail arithExprTail ] indice idnestTail termTail arithExprTail ) termTail arithExprTail exprTail ; statementTail } ; statementTail } ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id idnestTail termTail arithExprTail ] indice idnestTail termTail arithExprTail ) termTail arithExprTail exprTail ; statementTail } ; statementTail } ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id termTail arithExprTail ] indice idnestTail termTail arithExprTail ) termTail arithExprTail exprTail ; statementTail } ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id arithExprTail ] indice idnestTail termTail arithExprTail ) termTail arithExprTail exprTail ; statementTail } ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] indice idnestTail termTail arithExprTail ) termTail arithExprTail exprTail ; statementTail } ; statementTail } ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] idnestTail termTail arithExprTail ) termTail arithExprTail exprTail ; statementTail } ; statementTail } ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] termTail arithExprTail ) termTail arithExprTail exprTail ; statementTail } ; statementTail } ; 
USED RULE :
 termTail           -> multOp factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] multOp factor termTail arithExprTail ) termTail arithExprTail exprTail ; statementTail } ; statementTail } ; 
USED RULE :
 multOp            -> * 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * factor termTail arithExprTail ) termTail arithExprTail exprTail ; statementTail } ; statementTail } ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id idnest termTail arithExprTail ) termTail arithExprTail exprTail ; statementTail } ; statementTail } ; 
USED RULE :
 idnest             -> ( aParams ) idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( aParams ) idnestTail termTail arithExprTail ) termTail arithExprTail exprTail ; statementTail } ; statementTail } ; 
USED RULE :
 aParams            -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) idnestTail termTail arithExprTail ) termTail arithExprTail exprTail ; statementTail } ; statementTail } ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) termTail arithExprTail ) termTail arithExprTail exprTail ; statementTail } ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) arithExprTail ) termTail arithExprTail exprTail ; statementTail } ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) termTail arithExprTail exprTail ; statementTail } ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) arithExprTail exprTail ; statementTail } ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) exprTail ; statementTail } ; statementTail } ; 
USED RULE :
 exprTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; statementTail } ; statementTail } ; 
USED RULE :
 statementTail      -> statement 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; statement } ; statementTail } ; 
USED RULE :
 statement          -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; statementTail } ; 
USED RULE :
 statementTail      -> id statementId 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id statementId } ; 
USED RULE :
 statementId        -> assignStat ; statementTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id assignStat ; statementTail } ; 
USED RULE :
 assignStat         -> variable assignOp expr 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id variable assignOp expr ; statementTail } ; 
USED RULE :
 variable           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id assignOp expr ; statementTail } ; 
USED RULE :
 assignOp          -> = 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = expr ; statementTail } ; 
USED RULE :
 expr               -> arithExpr exprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = arithExpr exprTail ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = term arithExprTail exprTail ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = factor termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id idnest termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id indice idnestTail termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id idnestTail termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 idnestTail         -> . id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id idnest termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 idnest             -> ( aParams ) idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( aParams ) idnestTail termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 aParams            -> expr aParamsTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( expr aParamsTail ) idnestTail termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 expr               -> arithExpr exprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( arithExpr exprTail aParamsTail ) idnestTail termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( term arithExprTail exprTail aParamsTail ) idnestTail termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( factor termTail arithExprTail exprTail aParamsTail ) idnestTail termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id idnest termTail arithExprTail exprTail aParamsTail ) idnestTail termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id indice idnestTail termTail arithExprTail exprTail aParamsTail ) idnestTail termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id idnestTail termTail arithExprTail exprTail aParamsTail ) idnestTail termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id termTail arithExprTail exprTail aParamsTail ) idnestTail termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id arithExprTail exprTail aParamsTail ) idnestTail termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id exprTail aParamsTail ) idnestTail termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 exprTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id aParamsTail ) idnestTail termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 aParamsTail       -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) idnestTail termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) arithExprTail exprTail ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) exprTail ; statementTail } ; 
USED RULE :
 exprTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; statementTail } ; 
USED RULE :
 statementTail      -> id statementId 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id statementId } ; 
USED RULE :
 statementId        -> assignStat ; statementTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id assignStat ; statementTail } ; 
USED RULE :
 assignStat         -> variable assignOp expr 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id variable assignOp expr ; statementTail } ; 
USED RULE :
 variable           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id assignOp expr ; statementTail } ; 
USED RULE :
 assignOp          -> = 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = expr ; statementTail } ; 
USED RULE :
 expr               -> arithExpr exprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = arithExpr exprTail ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = term arithExprTail exprTail ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = factor termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id idnest termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id indice idnestTail termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id idnestTail termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 idnestTail         -> . id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id idnest termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 idnest             -> ( aParams ) idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( aParams ) idnestTail termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 aParams            -> expr aParamsTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( expr aParamsTail ) idnestTail termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 expr               -> arithExpr exprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( arithExpr exprTail aParamsTail ) idnestTail termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( term arithExprTail exprTail aParamsTail ) idnestTail termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( factor termTail arithExprTail exprTail aParamsTail ) idnestTail termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id idnest termTail arithExprTail exprTail aParamsTail ) idnestTail termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id indice idnestTail termTail arithExprTail exprTail aParamsTail ) idnestTail termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id idnestTail termTail arithExprTail exprTail aParamsTail ) idnestTail termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id termTail arithExprTail exprTail aParamsTail ) idnestTail termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id arithExprTail exprTail aParamsTail ) idnestTail termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id exprTail aParamsTail ) idnestTail termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 exprTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id aParamsTail ) idnestTail termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 aParamsTail       -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) idnestTail termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) arithExprTail exprTail ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) exprTail ; statementTail } ; 
USED RULE :
 exprTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; statementTail } ; 
USED RULE :
 statementTail      -> id statementId 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id statementId } ; 
USED RULE :
 statementId        -> assignStat ; statementTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id assignStat ; statementTail } ; 
USED RULE :
 assignStat         -> variable assignOp expr 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id variable assignOp expr ; statementTail } ; 
USED RULE :
 variable           -> . id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id idnest assignOp expr ; statementTail } ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 indice             -> [ arithExpr ] indice 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ arithExpr ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ term arithExprTail ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ factor termTail arithExprTail ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum termTail arithExprTail ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum arithExprTail ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 indice             -> [ arithExpr ] indice 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ arithExpr ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ term arithExprTail ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ factor termTail arithExprTail ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum termTail arithExprTail ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum arithExprTail ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 indice             -> [ arithExpr ] indice 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ arithExpr ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ term arithExprTail ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ factor termTail arithExprTail ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum termTail arithExprTail ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum arithExprTail ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 indice             -> [ arithExpr ] indice 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ arithExpr ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ term arithExprTail ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ factor termTail arithExprTail ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum termTail arithExprTail ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum arithExprTail ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 indice             -> [ arithExpr ] indice 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ arithExpr ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ term arithExprTail ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ factor termTail arithExprTail ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum termTail arithExprTail ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum arithExprTail ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 indice             -> [ arithExpr ] indice 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ arithExpr ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ term arithExprTail ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ factor termTail arithExprTail ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum termTail arithExprTail ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum arithExprTail ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 indice             -> [ arithExpr ] indice 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ arithExpr ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ term arithExprTail ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ factor termTail arithExprTail ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum termTail arithExprTail ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum arithExprTail ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] assignOp expr ; statementTail } ; 
USED RULE :
 assignOp          -> = 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = expr ; statementTail } ; 
USED RULE :
 expr               -> arithExpr exprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = arithExpr exprTail ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = term arithExprTail exprTail ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = factor termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum arithExprTail exprTail ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum exprTail ; statementTail } ; 
USED RULE :
 exprTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; statementTail } ; 
USED RULE :
 statementTail      -> id statementId 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id statementId } ; 
USED RULE :
 statementId        -> assignStat ; statementTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id assignStat ; statementTail } ; 
USED RULE :
 assignStat         -> variable assignOp expr 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id variable assignOp expr ; statementTail } ; 
USED RULE :
 variable           -> [ arithExpr ] indice variableTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ arithExpr ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ term arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ factor termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id idnest termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 idnestTail         -> . id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id idnest termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 indice             -> [ arithExpr ] indice 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ arithExpr ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ term arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ factor termTail arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum termTail arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 indice             -> [ arithExpr ] indice 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ arithExpr ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ term arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ factor termTail arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum termTail arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 indice             -> [ arithExpr ] indice 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ arithExpr ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ term arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ factor termTail arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum termTail arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 indice             -> [ arithExpr ] indice 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ arithExpr ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ term arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ factor termTail arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum termTail arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 indice             -> [ arithExpr ] indice 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ arithExpr ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ term arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ factor termTail arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum termTail arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 indice             -> [ arithExpr ] indice 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ arithExpr ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ term arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ factor termTail arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum termTail arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 indice             -> [ arithExpr ] indice 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ arithExpr ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ term arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ factor termTail arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id idnest termTail arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id indice idnestTail termTail arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id idnestTail termTail arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id termTail arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExprTail      -> addOp term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id addOp term arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 addOp             -> + 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + term arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + factor termTail arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id idnest termTail arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id indice idnestTail termTail arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id idnestTail termTail arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 idnestTail         -> id idnestTailTwo 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id idnestTailTwo termTail arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 idnestTailTwo      -> indice 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id indice termTail arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id termTail arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id arithExprTail ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] indice idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] idnestTail termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 indice             -> [ arithExpr ] indice 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ arithExpr ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ term arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ factor termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 indice             -> [ arithExpr ] indice 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ arithExpr ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ term arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ factor termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 indice             -> [ arithExpr ] indice 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ arithExpr ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ term arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ factor termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 factor             -> intNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum termTail arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum arithExprTail ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] indice variableTail assignOp expr ; statementTail } ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] variableTail assignOp expr ; statementTail } ; 
USED RULE :
 variableTail       -> . id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id idnest assignOp expr ; statementTail } ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id indice idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id idnestTail assignOp expr ; statementTail } ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id assignOp expr ; statementTail } ; 
USED RULE :
 assignOp          -> = 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = expr ; statementTail } ; 
USED RULE :
 expr               -> arithExpr exprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = arithExpr exprTail ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = term arithExprTail exprTail ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = factor termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 factor             -> floatNum 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = floatNum termTail arithExprTail exprTail ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = floatNum arithExprTail exprTail ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = floatNum exprTail ; statementTail } ; 
USED RULE :
 exprTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = floatNum ; statementTail } ; 
USED RULE :
 statementTail      -> statement 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = floatNum ; statement } ; 
USED RULE :
 statement          -> put ( expr ) ; statementTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = floatNum ; put ( expr ) ; statementTail } ; 
USED RULE :
 expr               -> arithExpr exprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = floatNum ; put ( arithExpr exprTail ) ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = floatNum ; put ( term arithExprTail exprTail ) ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = floatNum ; put ( factor termTail arithExprTail exprTail ) ; statementTail } ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = floatNum ; put ( id idnest termTail arithExprTail exprTail ) ; statementTail } ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = floatNum ; put ( id indice idnestTail termTail arithExprTail exprTail ) ; statementTail } ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = floatNum ; put ( id idnestTail termTail arithExprTail exprTail ) ; statementTail } ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = floatNum ; put ( id termTail arithExprTail exprTail ) ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = floatNum ; put ( id arithExprTail exprTail ) ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = floatNum ; put ( id exprTail ) ; statementTail } ; 
USED RULE :
 exprTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = floatNum ; put ( id ) ; statementTail } ; 
USED RULE :
 statementTail      -> statement 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = floatNum ; put ( id ) ; statement } ; 
USED RULE :
 statement          -> put ( expr ) ; statementTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = floatNum ; put ( id ) ; put ( expr ) ; statementTail } ; 
USED RULE :
 expr               -> arithExpr exprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = floatNum ; put ( id ) ; put ( arithExpr exprTail ) ; statementTail } ; 
USED RULE :
 arithExpr          -> term arithExprTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = floatNum ; put ( id ) ; put ( term arithExprTail exprTail ) ; statementTail } ; 
USED RULE :
 term               -> factor termTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = floatNum ; put ( id ) ; put ( factor termTail arithExprTail exprTail ) ; statementTail } ; 
USED RULE :
 factor             -> id idnest 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = floatNum ; put ( id ) ; put ( id idnest termTail arithExprTail exprTail ) ; statementTail } ; 
USED RULE :
 idnest             -> indice idnestTail 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = floatNum ; put ( id ) ; put ( id indice idnestTail termTail arithExprTail exprTail ) ; statementTail } ; 
USED RULE :
 indice             -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = floatNum ; put ( id ) ; put ( id idnestTail termTail arithExprTail exprTail ) ; statementTail } ; 
USED RULE :
 idnestTail         -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = floatNum ; put ( id ) ; put ( id termTail arithExprTail exprTail ) ; statementTail } ; 
USED RULE :
 termTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = floatNum ; put ( id ) ; put ( id arithExprTail exprTail ) ; statementTail } ; 
USED RULE :
 arithExprTail      -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = floatNum ; put ( id ) ; put ( id exprTail ) ; statementTail } ; 
USED RULE :
 exprTail           -> EPSILON 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = floatNum ; put ( id ) ; put ( id ) ; statementTail } ; 
USED RULE :
 statementTail      -> statement 

Sentencial Form:
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = floatNum ; put ( id ) ; put ( id ) ; statement } ; 
USED RULE :
 statement          -> EPSILON 

Successfully parsed! 
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = floatNum ; put ( id ) ; put ( id ) ; } ; 
Token Stream : 
 class id { int id ; } ; class id : id { int id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; float id ; int id ( int id [ intNum ] ) ; int id ( int id [ intNum ] ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id gt intNum ; id = id - intNum ) { if ( id [ id ] gt id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; int id sr id ( int id [ intNum ] ) { int id ; int id ; id = id [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = ( id ) + intNum ) { if ( id [ id ] lt id + intNum / intNum or id ) then { id = id [ id ] ; } else { } ; } ; return ( id ) ; } ; float id ( ) { float id ; id = intNum * ( intNum + floatNum / floatNum ) ; id = floatNum + ( ( floatNum * floatNum ) - floatNum ) + floatNum gt intNum and not - intNum ; return ( id ) ; } ; program { int id [ intNum ] ; int id ; int id ; int id ; id id ; id id [ intNum ] [ intNum ] [ intNum ] [ intNum ] ; for ( int id = intNum ; id leq intNum ; id = id + intNum ) { get ( id [ id ] ) ; id [ id ] = ( id [ id ] * id ( ) ) ; } ; id = id . id ( id ) ; id = id . id ( id ) ; id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] = intNum ; id [ id . id [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ intNum ] [ id + id id ] ] [ intNum ] [ intNum ] [ intNum ] . id = floatNum ; put ( id ) ; put ( id ) ; } ; $